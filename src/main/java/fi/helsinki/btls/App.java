/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package fi.helsinki.btls;

import fi.helsinki.ubipositioning.datamodels.Beacon;
import fi.helsinki.ubipositioning.datamodels.Location;
import fi.helsinki.ubipositioning.datamodels.Observation;
import fi.helsinki.ubipositioning.datamodels.Observer;
import fi.helsinki.ubipositioning.mqtt.IMqttService;
import fi.helsinki.ubipositioning.mqtt.MqttService;
import fi.helsinki.ubipositioning.trilateration.ILocationService;
import fi.helsinki.ubipositioning.trilateration.LocationService3D;
import fi.helsinki.ubipositioning.utils.IObserverService;
import fi.helsinki.ubipositioning.utils.ObservationGenerator;
import fi.helsinki.ubipositioning.utils.ObserverService;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class App {
    public static void main(String[] args) {
        PropertiesHandler handler = new PropertiesHandler("config/mqttConfig.properties");

        String subscribeTopic = handler.getProperty("subscribeTopic");
        String publishTopic = handler.getProperty("publishTopic");
        String mqttUrl = handler.getProperty("mqttUrl");
        boolean debug = Boolean.parseBoolean(handler.getProperty("debug"));

        IMqttService mqttService = new MqttService(mqttUrl,subscribeTopic,publishTopic);
        mqttService.setObservationLifetime(5);

        int positionsDimension = 3;
        IObserverService observerService = new ObserverService(positionsDimension);
        Map<String, String> allProperties = new PropertiesHandler("config/rasps.properties").getAllProperties();
        List<Observer> all = new ArrayList<>();
        List<String> observerKeys = new ArrayList<>();

        allProperties.forEach((key, value) -> {
            String[] rasp = value.split(":");
            double[] temp = new double[positionsDimension];

            for (int i = 0; i < positionsDimension; i++) {
                temp[i] = Double.parseDouble(rasp[i]);
            }

            Observer obs = new Observer(key);
            obs.setPosition(temp);
            all.add(obs);

            observerKeys.add(key);
        });

        if (!observerService.addAllObservers(all)) {
            return;
        }

        ObservationGenerator obsMock = new ObservationGenerator(12, 30, observerKeys);
        ILocationService service = new LocationService3D(observerService);
        service.setCalculateDistance(true);
        while (true) {
            try {
                Thread.sleep(1000);
                List<Beacon> beacons;

                if (debug) {
                    beacons = obsMock.getBeacons();
                } else {
                    beacons = mqttService.getBeacons();
                }
                printDistances(service, beacons);
                List<Location> locations = service.calculateAllLocations(beacons);
                mqttService.publish(locations);
            } catch (Exception ex) {
                System.out.println(ex.toString());
            }
        }
    }

    private static void printDistances(ILocationService service, List<Beacon> beacons) {
        beacons.forEach(x -> {
            String distanceString = x.getId();
            List<String> rasps = new ArrayList<>();
            for (int i = x.getObservations().size() - 1; i >= 0; i--) {
                Observation observation = x.getObservations().get(i);
                if (!rasps.contains(observation.getRaspId())) {
                    rasps.add(observation.getRaspId());
                    distanceString += "\n" + observation.getRaspId() + ":\t" +
                            service.getDistanceFromRssi(observation.getRssi(), x.getMinRSSI()) +
                            "\t" + observation.getTimestamp();
                }
            }
            System.out.println(distanceString);
        });
    }
}
